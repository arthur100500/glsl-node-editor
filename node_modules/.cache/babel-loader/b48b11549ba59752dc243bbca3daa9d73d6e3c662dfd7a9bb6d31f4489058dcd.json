{"ast":null,"code":"export default class NodeFactory {\n  fromJson(jsonCode) {\n    let nodeObject = JSON.parse(jsonCode);\n    return this.fromObject(nodeObject);\n  }\n  fromObject(nodeObject) {\n    let inputsObjects = [];\n    for (var i in nodeObject.inputs) inputsObjects.push({\n      name: nodeObject.inputs[i].name,\n      type: nodeObject.inputs[i].type\n    });\n    NodeFactory.latestNodeID = Math.max(NodeFactory.latestNodeID, nodeObject.id + 1);\n    return {\n      id: \"node-\" + nodeObject.id,\n      position: {\n        x: nodeObject.positionX,\n        y: nodeObject.positionY\n      },\n      type: 'usual',\n      data: {\n        id: \"node-\" + nodeObject.id,\n        title: nodeObject.name,\n        inputs: inputsObjects,\n        type: nodeObject.output.type,\n        code: nodeObject.code\n      }\n    };\n  }\n  static manyFromJson(jsonCode) {\n    let nodeObjects = JSON.parse(jsonCode);\n    let nodeObjectsParsed = [];\n    for (var index in nodeObjects) nodeObjectsParsed.push(this.fromObject(nodeObjects[index]));\n    return nodeObjectsParsed;\n  }\n  static fromCode(glslCode) {\n    let fnCode = glslCode.trim();\n    let node = {\n      id: '' + this.latestNodeID\n    };\n    node.additionElements = additionalElems;\n    const regexp = /[a-zA-Z_0-9]+ [a-zA-Z_0-9\\[\\]]+/g;\n    const array = [...fnCode.split(\"\\n\")[0].match(regexp)];\n    node.data.title = array[0].split(\" \")[1];\n    node.data.type = new NodeOutput(node, array[0].split(\" \")[0], \"result\", 0);\n    for (let i = 1; i < array.length; i++) node.data.inputs[i - 1] = {\n      name: array[i].split(\" \")[0],\n      type: array[i].split(\" \")[1],\n      id: i - 1\n    };\n    for (let i = 0; i < additionalParams.length; i++) node.data.parameters[i] = {\n      name: additionalParams[i].split(\" \")[0],\n      type: additionalParams[i].split(\" \")[1],\n      i\n    };\n    let header = fnCode.split(\"{\")[0].replace(\")\", \"\") + (array.length > 1 && additionalParams.length > 0 ? \", \" : \"\") + additionalParams.join(\", \") + \"){\";\n    node.data.code = header + fnCode.split(\"{\").slice(1).join(\"{\");\n    return node;\n  }\n}\nNodeFactory.latestNodeID = 0;","map":{"version":3,"names":["NodeFactory","fromJson","jsonCode","nodeObject","JSON","parse","fromObject","inputsObjects","i","inputs","push","name","type","latestNodeID","Math","max","id","position","x","positionX","y","positionY","data","title","output","code","manyFromJson","nodeObjects","nodeObjectsParsed","index","fromCode","glslCode","fnCode","trim","node","additionElements","additionalElems","regexp","array","split","match","NodeOutput","length","additionalParams","parameters","header","replace","join","slice"],"sources":["/home/arhur/Documents/GitHub/NodeEditor/src/nodes/NodeFactory.js"],"sourcesContent":["export default class NodeFactory {\n    static latestNodeID = 0;\n\n    fromJson(jsonCode) {\n        let nodeObject = JSON.parse(jsonCode);\n        return this.fromObject(nodeObject);\n    }\n\n    fromObject(nodeObject) {\n        let inputsObjects = [];\n        for (var i in nodeObject.inputs)\n            inputsObjects.push({\n                name: nodeObject.inputs[i].name,\n                type: nodeObject.inputs[i].type\n            });\n\n        NodeFactory.latestNodeID = Math.max(NodeFactory.latestNodeID, nodeObject.id + 1);\n\n        return {\n            id: \"node-\" + nodeObject.id,\n            position: { x: nodeObject.positionX, y: nodeObject.positionY },\n            type: 'usual',\n            data: {\n                id: \"node-\" + nodeObject.id,\n                title: nodeObject.name,\n                inputs: inputsObjects,\n                type: nodeObject.output.type,\n                code: nodeObject.code,\n            }\n        }\n    }\n\n    static manyFromJson(jsonCode) {\n        let nodeObjects = JSON.parse(jsonCode);\n        let nodeObjectsParsed = [];\n        for (var index in nodeObjects)\n            nodeObjectsParsed.push(this.fromObject(nodeObjects[index]));\n\n        return nodeObjectsParsed;\n    }\n\n    static fromCode(glslCode) {\n        let fnCode = glslCode.trim();\n        let node = {id: ''+this.latestNodeID};\n        node.additionElements = additionalElems;\n\n        const regexp = /[a-zA-Z_0-9]+ [a-zA-Z_0-9\\[\\]]+/g;\n        const array = [...fnCode.split(\"\\n\")[0].match(regexp)];\n\n        node.data.title = array[0].split(\" \")[1];\n        node.data.type = new NodeOutput(node, array[0].split(\" \")[0], \"result\", 0);\n\n        for (let i = 1; i < array.length; i++)\n            node.data.inputs[i - 1] = { name: array[i].split(\" \")[0], type: array[i].split(\" \")[1], id: i - 1}\n\n        for (let i = 0; i < additionalParams.length; i++)\n            node.data.parameters[i] = { name: additionalParams[i].split(\" \")[0], type: additionalParams[i].split(\" \")[1], i }\n\n        let header = fnCode.split(\"{\")[0].replace(\")\", \"\") + ((array.length > 1 && additionalParams.length > 0) ? \", \" : \"\") + additionalParams.join(\", \") + \"){\";\n        node.data.code = header + fnCode.split(\"{\").slice(1).join(\"{\");\n        return node;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}