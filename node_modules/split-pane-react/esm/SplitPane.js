var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React, { useEffect, useMemo, useCallback, useRef, useState } from 'react';
import Pane from './pane';
import Sash from './sash';
import SashContent from './SashContent';
import { classNames, bodyDisableUserSelect, paneClassName, splitClassName, splitDragClassName, splitVerticalClassName, splitHorizontalClassName, sashDisabledClassName, sashHorizontalClassName, sashVerticalClassName, assertsSize } from './base';
const SplitPane = (_a) => {
    var _b;
    var { children, sizes: propSizes, allowResize = true, split = 'vertical', className: wrapClassName, sashRender = (_, active) => React.createElement(SashContent, { active: active, type: 'vscode' }), resizerSize = 4, performanceMode = false, onChange = () => null, onDragStart = () => null, onDragEnd = () => null } = _a, others = __rest(_a, ["children", "sizes", "allowResize", "split", "className", "sashRender", "resizerSize", "performanceMode", "onChange", "onDragStart", "onDragEnd"]);
    const axis = useRef({ x: 0, y: 0 });
    const wrapper = useRef(null);
    const cacheSizes = useRef({ sizes: [], sashPosSizes: [] });
    const [wrapperRect, setWrapperRect] = useState({});
    const [isDragging, setDragging] = useState(false);
    useEffect(() => {
        const resizeObserver = new ResizeObserver(() => {
            var _a, _b;
            setWrapperRect((_b = (_a = wrapper === null || wrapper === void 0 ? void 0 : wrapper.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) !== null && _b !== void 0 ? _b : {});
        });
        resizeObserver.observe(wrapper.current);
        return () => {
            resizeObserver.disconnect();
        };
    }, []);
    const { sizeName, splitPos, splitAxis } = useMemo(() => ({
        sizeName: split === 'vertical' ? 'width' : 'height',
        splitPos: split === 'vertical' ? 'left' : 'top',
        splitAxis: split === 'vertical' ? 'x' : 'y'
    }), [split]);
    const wrapSize = (_b = wrapperRect[sizeName]) !== null && _b !== void 0 ? _b : 0;
    // Get limit sizes via children
    const paneLimitSizes = useMemo(() => children.map(childNode => {
        const limits = [0, Infinity];
        if (childNode.type === Pane) {
            const { minSize, maxSize } = childNode.props;
            limits[0] = assertsSize(minSize, wrapSize, 0);
            limits[1] = assertsSize(maxSize, wrapSize);
        }
        return limits;
    }), [children, wrapSize]);
    const sizes = useMemo(function () {
        let count = 0;
        let curSum = 0;
        const res = children.map((_, index) => {
            const size = assertsSize(propSizes[index], wrapSize);
            size === Infinity ? count++ : curSum += size;
            return size;
        });
        // resize or illegal size input,recalculate pane sizes
        if (curSum > wrapSize || !count && curSum < wrapSize) {
            const cacheNum = (curSum - wrapSize) / curSum;
            return res.map(size => {
                return size === Infinity ? 0 : size - size * cacheNum;
            });
        }
        if (count > 0) {
            const average = (wrapSize - curSum) / count;
            return res.map(size => {
                return size === Infinity ? average : size;
            });
        }
        return res;
    }, [...propSizes, children.length, wrapSize]);
    const sashPosSizes = useMemo(() => (sizes.reduce((a, b) => [...a, a[a.length - 1] + b], [0])), [...sizes]);
    const dragStart = useCallback(function (e) {
        var _a, _b;
        (_b = (_a = document === null || document === void 0 ? void 0 : document.body) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.add(bodyDisableUserSelect);
        axis.current = { x: e.pageX, y: e.pageY };
        cacheSizes.current = { sizes, sashPosSizes };
        setDragging(true);
        onDragStart(e);
    }, [onDragStart, sizes, sashPosSizes]);
    const dragEnd = useCallback(function (e) {
        var _a, _b;
        (_b = (_a = document === null || document === void 0 ? void 0 : document.body) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.remove(bodyDisableUserSelect);
        axis.current = { x: e.pageX, y: e.pageY };
        cacheSizes.current = { sizes, sashPosSizes };
        setDragging(false);
        onDragEnd(e);
    }, [onDragEnd, sizes, sashPosSizes]);
    const onDragging = useCallback(function (e, i) {
        const curAxis = { x: e.pageX, y: e.pageY };
        let distanceX = curAxis[splitAxis] - axis.current[splitAxis];
        const leftBorder = -Math.min(sizes[i] - paneLimitSizes[i][0], paneLimitSizes[i + 1][1] - sizes[i + 1]);
        const rightBorder = Math.min(sizes[i + 1] - paneLimitSizes[i + 1][0], paneLimitSizes[i][1] - sizes[i]);
        if (distanceX < leftBorder) {
            distanceX = leftBorder;
        }
        if (distanceX > rightBorder) {
            distanceX = rightBorder;
        }
        const nextSizes = [...sizes];
        nextSizes[i] += distanceX;
        nextSizes[i + 1] -= distanceX;
        onChange(nextSizes);
    }, [paneLimitSizes, onChange]);
    const paneFollow = !(performanceMode && isDragging);
    const paneSizes = paneFollow ? sizes : cacheSizes.current.sizes;
    const panePoses = paneFollow ? sashPosSizes : cacheSizes.current.sashPosSizes;
    return (React.createElement("div", Object.assign({ className: classNames(splitClassName, split === 'vertical' && splitVerticalClassName, split === 'horizontal' && splitHorizontalClassName, isDragging && splitDragClassName, wrapClassName), ref: wrapper }, others),
        children.map((childNode, childIndex) => {
            const isPane = childNode.type === Pane;
            const paneProps = isPane ? childNode.props : {};
            return (React.createElement(Pane, { key: childIndex, className: classNames(paneClassName, paneProps.className), style: Object.assign(Object.assign({}, paneProps.style), { [sizeName]: paneSizes[childIndex], [splitPos]: panePoses[childIndex] }) }, isPane ? paneProps.children : childNode));
        }),
        sashPosSizes.slice(1, -1).map((posSize, index) => (React.createElement(Sash, { key: index, className: classNames(!allowResize && sashDisabledClassName, split === 'vertical'
                ? sashVerticalClassName
                : sashHorizontalClassName), style: {
                [sizeName]: resizerSize,
                [splitPos]: posSize - resizerSize / 2
            }, render: sashRender.bind(null, index), onDragStart: dragStart, onDragging: e => onDragging(e, index), onDragEnd: dragEnd })))));
};
export default SplitPane;
